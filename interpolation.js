// Generated by LiveScript 1.2.0
(function(){
  var width, height, x, y, color, xAxis, yAxis;
  width = 600;
  height = 800;
  x = d3.scale.linear().range([0, width]);
  y = d3.scale.linear().range([height, 0]);
  color = d3.scale.linear().domain([10, 20, 30, 40, 50, 70, 90, 110, 130, 150, 200, 250, 300, 350, 400, 450]).range(['#c5bec2', '#99feff', '#00ccfc', '#0795fd', '#025ffe', '#3c9700', '#2bfe00', '#fdfe00', '#ffcb00', '#eaa200', '#f30500', '#d60002', '#9e0003', '#9e009d', '#d400d1', '#fa00ff', '#facefb']);
  xAxis = d3.svg.axis().scale(x).orient('bottom').ticks(20);
  yAxis = d3.svg.axis().scale(y).orient('left');
  d3.json("stations.json", function(stations){
    return d3.json("twCounty2010.topo.json", function(countiestopo){
      var counties, root, current, rainData, samples, canvas, svg, distance, idwInterpolate, yPixel, plotInterpolatedData;
      counties = topojson.feature(countiestopo, countiestopo.objects['twCounty2010.geo']);
      root = new Firebase("https://cwbtw.firebaseio.com");
      current = root.child("rainfall/2013-07-13/23:50:00");
      rainData = {};
      samples = {};
      canvas = d3.select('body').append('canvas').attr('width', width).attr('height', height)[0][0].getContext('2d');
      svg = d3.select("body").append("svg").attr("width", width).attr("height", height);
      distance = function(arg$, arg1$){
        var x1, y1, x2, y2;
        x1 = arg$[0], y1 = arg$[1];
        x2 = arg1$[0], y2 = arg1$[1];
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      };
      idwInterpolate = function(samples, power, point){
        var sum, sumWeight, i$, len$, s, d, weight;
        sum = 0.0;
        sumWeight = 0.0;
        for (i$ = 0, len$ = samples.length; i$ < len$; ++i$) {
          s = samples[i$];
          d = distance(s, point);
          if (d === 0.0) {
            return s[2];
          }
          weight = Math.pow(d, -power);
          sum = sum + weight;
          sumWeight = sumWeight + weight * s[2];
        }
        return sumWeight / sum;
      };
      yPixel = 0;
      plotInterpolatedData = function(){
        var minLatitude, maxLatitude, minLongitude, maxLongitude, dy, dx, renderLine;
        minLatitude = 21.5;
        maxLatitude = 25.5;
        minLongitude = 119.5;
        maxLongitude = 122.5;
        dy = (maxLatitude - minLatitude) / height;
        dx = (maxLongitude - minLongitude) / width;
        yPixel = height;
        renderLine = function(){
          var i$, to$, xPixel, y, x, z, ref$, c, drawPolygon, len$, ct, j$, ref1$, len1$, coordinate, k$, len2$, polygon, st, results$ = [];
          if (yPixel >= 0) {
            for (i$ = 0, to$ = width; i$ <= to$; i$ += 2) {
              xPixel = i$;
              y = minLatitude + dy * yPixel;
              x = minLongitude + dx * xPixel;
              z = 0 > (ref$ = idwInterpolate(samples, 2.75, [x, y])) ? 0 : ref$;
              c = (500.0 - z) / 500.0 * 240;
              canvas.fillStyle = d3.hsl(c, 0.6, 0.5).toString();
              canvas.fillRect(xPixel, height - yPixel, 2, 2);
            }
            yPixel = yPixel - 2;
            return setTimeout(renderLine, 0);
          } else {
            drawPolygon = function(polygon, ctx){
              var firstPoint, i$, len$, pt, x, y;
              ctx.strokeStyle = '#eee';
              ctx.lineWidth = 1;
              firstPoint = true;
              ctx.beginPath();
              console.log(polygon);
              for (i$ = 0, len$ = polygon.length; i$ < len$; ++i$) {
                pt = polygon[i$];
                x = (pt[0] - minLongitude) / dx;
                y = height - (pt[1] - minLatitude) / dx;
                if (firstPoint) {
                  ctx.moveTo(x, y);
                  firstPoint = false;
                } else {
                  ctx.lineTo(x, y);
                }
              }
              ctx.closePath();
              return ctx.stroke();
            };
            for (i$ = 0, len$ = (ref$ = counties.features).length; i$ < len$; ++i$) {
              ct = ref$[i$];
              for (j$ = 0, len1$ = (ref1$ = ct.geometry.coordinates).length; j$ < len1$; ++j$) {
                coordinate = ref1$[j$];
                if (ct.geometry.type === 'MultiPolygon') {
                  for (k$ = 0, len2$ = coordinate.length; k$ < len2$; ++k$) {
                    polygon = coordinate[k$];
                    drawPolygon(polygon, canvas);
                  }
                } else if (ct.geometry.type === 'Polygon') {
                  drawPolygon(coordinate, canvas);
                } else {
                  console.log(ct.geometry.type);
                }
              }
            }
            canvas.strokeStyle = '#000';
            canvas.lineWidth = 1;
            for (i$ = 0, len$ = (ref$ = stations).length; i$ < len$; ++i$) {
              st = ref$[i$];
              x = (+st.longitude - minLongitude) / dx;
              y = height - (+st.latitude - minLatitude) / dx;
              canvas.beginPath();
              canvas.arc(x, y, 2.0, 0, 2 * Math.PI, false);
              canvas.closePath();
              results$.push(canvas.stroke());
            }
            return results$;
          }
        };
        return renderLine();
      };
      return current.on('value', function(it){
        var res$, i$, ref$, len$, st;
        rainData = it.val();
        res$ = [];
        for (i$ = 0, len$ = (ref$ = stations).length; i$ < len$; ++i$) {
          st = ref$[i$];
          if (rainData[st.name] != null && !isNaN(rainData[st.name]['today'])) {
            res$.push([+st.longitude, +st.latitude, parseFloat(rainData[st.name]['today'])]);
          }
        }
        samples = res$;
        return plotInterpolatedData();
      });
    });
  });
}).call(this);
